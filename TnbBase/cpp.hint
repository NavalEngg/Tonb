// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define TMP_UNARY_FUNCTION(ReturnType, Func) template<class Type> ReturnType Func(const tmp<Field<Type> >& tf1);
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define TMP_UNARY_FUNCTION(ReturnType, Func) template<class Type> ReturnType Func(const tmp<Field<Type> >& tf1);
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define G_UNARY_FUNCTION(ReturnType, gFunc, Func, rFunc) template<class Type> ReturnType gFunc(const UList<Type>& f); TMP_UNARY_FUNCTION(ReturnType, gFunc)
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define BINARY_TYPE_FUNCTION(ReturnType, Type1, Type2, Func) BINARY_TYPE_FUNCTION_SF(ReturnType, Type1, Type2, Func) BINARY_TYPE_FUNCTION_FS(ReturnType, Type1, Type2, Func)
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define TFOR_ALL_F_OP_FUNC_F(typeF1, f1, OP, FUNC, typeF2, f2) checkFields(f1, f2, "f1 " #OP " " #FUNC "(f2)"); List_ACCESS(typeF1, f1, f1P); List_CONST_ACCESS(typeF2, f2, f2P); List_FOR_ALL(f1, i) List_ELEM(f1, f1P, i) OP FUNC(List_ELEM(f2, f2P, i)); List_END_FOR_ALL
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define TFOR_ALL_F_OP_FUNC_F(typeF1, f1, OP, FUNC, typeF2, f2) checkFields(f1, f2, "f1 " #OP " " #FUNC "(f2)"); List_ACCESS(typeF1, f1, f1P); List_CONST_ACCESS(typeF2, f2, f2P); List_FOR_ALL(f1, i) List_ELEM(f1, f1P, i) OP FUNC(List_ELEM(f2, f2P, i)); List_END_FOR_ALL
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define TMP_UNARY_FUNCTION(ReturnType, Func) template<class Type> ReturnType Func(const tmp<Field<Type> >& tf1);
#define TMP_UNARY_FUNCTION(ReturnType, Func) template<class Type> ReturnType Func(const tmp<Field<Type> >& tf1) { ReturnType res = Func(tf1()); tf1.clear(); return res; }
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define PRODUCT_OPERATOR(product, op, opFunc) template<class Type1, class Type2> dimensioned<typename product<Type1, Type2>::type> operator op(const dimensioned<Type1>&, const dimensioned<Type2>&); template<class Type, class Form, class Cmpt, int nCmpt> dimensioned<typename product<Type, Form>::type> operator op ( const dimensioned<Type>&, const VectorSpace<Form,Cmpt,nCmpt>& ); template<class Type, class Form, class Cmpt, int nCmpt> dimensioned<typename product<Form, Type>::type> operator op ( const VectorSpace<Form,Cmpt,nCmpt>&, const dimensioned<Type>& );
#define PRODUCT_OPERATOR(product, Op, OpFunc) template<class Type1, class Type2> void OpFunc ( Field<typename product<Type1, Type2>::type>& res, const UList<Type1>& f1, const UList<Type2>& f2 ); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const UList<Type2>& f2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const tmp<Field<Type2> >& tf2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const UList<Type2>& f2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const tmp<Field<Type2> >& tf2); template<class Type, class Form, class Cmpt, int nCmpt> void OpFunc ( Field<typename product<Type, Form>::type>& res, const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs ); template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs); template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const tmp<Field<Type> >&tf1,const VectorSpace<Form,Cmpt,nCmpt>&vs); template<class Form, class Cmpt, int nCmpt, class Type> void OpFunc ( Field<typename product<Form, Type>::type>& res, const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1 ); template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1); template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>&vs,const tmp<Field<Type> >&tf1);
#define PRODUCT_OPERATOR(product, Op, OpFunc) template<class Type1, class Type2> void OpFunc ( Field<typename product<Type1, Type2>::type>& res, const UList<Type1>& f1, const UList<Type2>& f2 ) { typedef typename product<Type1, Type2>::type productType; TFOR_ALL_F_OP_F_OP_F(productType, res, =, Type1, f1, Op, Type2, f2) } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const UList<Type2>& f2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), f1, f2); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const tmp<Field<Type2> >& tf2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type2>::New(tf2); OpFunc(tRes(), f1, tf2()); reuseTmp<productType, Type2>::clear(tf2); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const UList<Type2>& f2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type1>::New(tf1); OpFunc(tRes(), tf1(), f2); reuseTmp<productType, Type1>::clear(tf1); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const tmp<Field<Type2> >& tf2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmpTmp<productType, Type1, Type1, Type2>::New(tf1, tf2); OpFunc(tRes(), tf1(), tf2()); reuseTmpTmp<productType, Type1, Type1, Type2>::clear(tf1, tf2); return tRes; } template<class Type, class Form, class Cmpt, int nCmpt> void OpFunc ( Field<typename product<Type, Form>::type>& res, const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs ) { typedef typename product<Type, Form>::type productType; TFOR_ALL_F_OP_F_OP_S (productType, res, =,Type, f1, Op, Form, static_cast<const Form&>(vs))} template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs) { typedef typename product<Type, Form>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), f1, static_cast<const Form&>(vs)); return tRes; } template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op ( const tmp<Field<Type> >& tf1, const VectorSpace<Form,Cmpt,nCmpt>& vs ) { typedef typename product<Type, Form>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type>::New(tf1); OpFunc(tRes(), tf1(), static_cast<const Form&>(vs)); reuseTmp<productType, Type>::clear(tf1); return tRes; } template<class Form, class Cmpt, int nCmpt, class Type> void OpFunc ( Field<typename product<Form, Type>::type>& res, const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1 ) { typedef typename product<Form, Type>::type productType; TFOR_ALL_F_OP_S_OP_F (productType, res, =,Form,static_cast<const Form&>(vs), Op, Type, f1) } template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1) { typedef typename product<Form, Type>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), static_cast<const Form&>(vs), f1); return tRes; } template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op ( const VectorSpace<Form,Cmpt,nCmpt>& vs, const tmp<Field<Type> >& tf1 ) { typedef typename product<Form, Type>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type>::New(tf1); OpFunc(tRes(), static_cast<const Form&>(vs), tf1()); reuseTmp<productType, Type>::clear(tf1); return tRes; }
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define TMP_UNARY_FUNCTION(ReturnType, Func) template<class Type> ReturnType Func(const tmp<Field<Type> >& tf1);
#define TMP_UNARY_FUNCTION(ReturnType, Func) template<class Type> ReturnType Func(const tmp<Field<Type> >& tf1) { ReturnType res = Func(tf1()); tf1.clear(); return res; }
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define G_UNARY_FUNCTION(ReturnType, gFunc, Func, rFunc) template<class Type> ReturnType gFunc(const UList<Type>& f); TMP_UNARY_FUNCTION(ReturnType, gFunc)
#define G_UNARY_FUNCTION(ReturnType, gFunc, Func, rFunc) template<class Type> ReturnType gFunc(const UList<Type>& f) { ReturnType res = Func(f); reduce(res, rFunc##Op<ReturnType>()); return res; } TMP_UNARY_FUNCTION(ReturnType, gFunc)
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define G_UNARY_FUNCTION(ReturnType, gFunc, Func, rFunc) template<class Type> ReturnType gFunc(const UList<Type>& f); TMP_UNARY_FUNCTION(ReturnType, gFunc)
#define G_UNARY_FUNCTION(ReturnType, gFunc, Func, rFunc) template<class Type> ReturnType gFunc(const UList<Type>& f) { ReturnType res = Func(f); reduce(res, rFunc##Op<ReturnType>()); return res; } TMP_UNARY_FUNCTION(ReturnType, gFunc)
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define TMP_UNARY_FUNCTION(ReturnType, Func) template<class Type> ReturnType Func(const tmp<Field<Type> >& tf1);
#define TMP_UNARY_FUNCTION(ReturnType, Func) template<class Type> ReturnType Func(const tmp<Field<Type> >& tf1) { ReturnType res = Func(tf1()); tf1.clear(); return res; }
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define TFOR_ALL_F_OP_F_FUNC_S(typeF1, f1, OP, typeF2, f2, FUNC, typeS, s) checkFields(f1, f2, "f1 " #OP " f2 " #FUNC "(s)"); List_ACCESS(typeF1, f1, f1P); List_CONST_ACCESS(typeF2, f2, f2P); List_FOR_ALL(f1, i) List_ELEM(f1, f1P, i) OP List_ELEM(f2, f2P, i) FUNC((s)); List_END_FOR_ALL
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define TFOR_ALL_F_OP_F_FUNC(typeF1, f1, OP, typeF2, f2, FUNC) checkFields(f1, f2, "f1 " #OP " f2" #FUNC); List_ACCESS(typeF1, f1, f1P); List_CONST_ACCESS(typeF2, f2, f2P); List_FOR_ALL(f1, i) List_ELEM(f1, f1P, i) OP List_ELEM(f2, f2P, i).FUNC(); List_END_FOR_ALL
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define TFOR_ALL_F_OP_FUNC_F_S(typeF1, f1, OP, FUNC, typeF2, f2, typeS, s) checkFields(f1, f2, "f1 " #OP " " #FUNC "(f2, s)"); List_ACCESS(typeF1, f1, f1P); List_CONST_ACCESS(typeF2, f2, f2P); List_FOR_ALL(f1, i) List_ELEM(f1, f1P, i) OP FUNC(List_ELEM(f2, f2P, i), (s)); List_END_FOR_ALL
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define PRODUCT_OPERATOR(product, op, opFunc) template<class Type1, class Type2> dimensioned<typename product<Type1, Type2>::type> operator op(const dimensioned<Type1>&, const dimensioned<Type2>&); template<class Type, class Form, class Cmpt, int nCmpt> dimensioned<typename product<Type, Form>::type> operator op ( const dimensioned<Type>&, const VectorSpace<Form,Cmpt,nCmpt>& ); template<class Type, class Form, class Cmpt, int nCmpt> dimensioned<typename product<Form, Type>::type> operator op ( const VectorSpace<Form,Cmpt,nCmpt>&, const dimensioned<Type>& );
#define PRODUCT_OPERATOR(product, Op, OpFunc) template<class Type1, class Type2> void OpFunc ( Field<typename product<Type1, Type2>::type>& res, const UList<Type1>& f1, const UList<Type2>& f2 ); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const UList<Type2>& f2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const tmp<Field<Type2> >& tf2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const UList<Type2>& f2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const tmp<Field<Type2> >& tf2); template<class Type, class Form, class Cmpt, int nCmpt> void OpFunc ( Field<typename product<Type, Form>::type>& res, const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs ); template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs); template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const tmp<Field<Type> >&tf1,const VectorSpace<Form,Cmpt,nCmpt>&vs); template<class Form, class Cmpt, int nCmpt, class Type> void OpFunc ( Field<typename product<Form, Type>::type>& res, const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1 ); template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1); template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>&vs,const tmp<Field<Type> >&tf1);
#define PRODUCT_OPERATOR(product, Op, OpFunc) template<class Type1, class Type2> void OpFunc ( Field<typename product<Type1, Type2>::type>& res, const UList<Type1>& f1, const UList<Type2>& f2 ) { typedef typename product<Type1, Type2>::type productType; TFOR_ALL_F_OP_F_OP_F(productType, res, =, Type1, f1, Op, Type2, f2) } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const UList<Type2>& f2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), f1, f2); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const tmp<Field<Type2> >& tf2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type2>::New(tf2); OpFunc(tRes(), f1, tf2()); reuseTmp<productType, Type2>::clear(tf2); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const UList<Type2>& f2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type1>::New(tf1); OpFunc(tRes(), tf1(), f2); reuseTmp<productType, Type1>::clear(tf1); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const tmp<Field<Type2> >& tf2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmpTmp<productType, Type1, Type1, Type2>::New(tf1, tf2); OpFunc(tRes(), tf1(), tf2()); reuseTmpTmp<productType, Type1, Type1, Type2>::clear(tf1, tf2); return tRes; } template<class Type, class Form, class Cmpt, int nCmpt> void OpFunc ( Field<typename product<Type, Form>::type>& res, const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs ) { typedef typename product<Type, Form>::type productType; TFOR_ALL_F_OP_F_OP_S (productType, res, =,Type, f1, Op, Form, static_cast<const Form&>(vs))} template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs) { typedef typename product<Type, Form>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), f1, static_cast<const Form&>(vs)); return tRes; } template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op ( const tmp<Field<Type> >& tf1, const VectorSpace<Form,Cmpt,nCmpt>& vs ) { typedef typename product<Type, Form>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type>::New(tf1); OpFunc(tRes(), tf1(), static_cast<const Form&>(vs)); reuseTmp<productType, Type>::clear(tf1); return tRes; } template<class Form, class Cmpt, int nCmpt, class Type> void OpFunc ( Field<typename product<Form, Type>::type>& res, const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1 ) { typedef typename product<Form, Type>::type productType; TFOR_ALL_F_OP_S_OP_F (productType, res, =,Form,static_cast<const Form&>(vs), Op, Type, f1) } template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1) { typedef typename product<Form, Type>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), static_cast<const Form&>(vs), f1); return tRes; } template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op ( const VectorSpace<Form,Cmpt,nCmpt>& vs, const tmp<Field<Type> >& tf1 ) { typedef typename product<Form, Type>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type>::New(tf1); OpFunc(tRes(), static_cast<const Form&>(vs), tf1()); reuseTmp<productType, Type>::clear(tf1); return tRes; }
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define PRODUCT_OPERATOR(product, op, opFunc) template<class Type1, class Type2> dimensioned<typename product<Type1, Type2>::type> operator op(const dimensioned<Type1>&, const dimensioned<Type2>&); template<class Type, class Form, class Cmpt, int nCmpt> dimensioned<typename product<Type, Form>::type> operator op ( const dimensioned<Type>&, const VectorSpace<Form,Cmpt,nCmpt>& ); template<class Type, class Form, class Cmpt, int nCmpt> dimensioned<typename product<Form, Type>::type> operator op ( const VectorSpace<Form,Cmpt,nCmpt>&, const dimensioned<Type>& );
#define PRODUCT_OPERATOR(product, Op, OpFunc) template<class Type1, class Type2> void OpFunc ( Field<typename product<Type1, Type2>::type>& res, const UList<Type1>& f1, const UList<Type2>& f2 ); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const UList<Type2>& f2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const tmp<Field<Type2> >& tf2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const UList<Type2>& f2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const tmp<Field<Type2> >& tf2); template<class Type, class Form, class Cmpt, int nCmpt> void OpFunc ( Field<typename product<Type, Form>::type>& res, const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs ); template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs); template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const tmp<Field<Type> >&tf1,const VectorSpace<Form,Cmpt,nCmpt>&vs); template<class Form, class Cmpt, int nCmpt, class Type> void OpFunc ( Field<typename product<Form, Type>::type>& res, const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1 ); template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1); template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>&vs,const tmp<Field<Type> >&tf1);
#define PRODUCT_OPERATOR(product, Op, OpFunc) template<class Type1, class Type2> void OpFunc ( Field<typename product<Type1, Type2>::type>& res, const UList<Type1>& f1, const UList<Type2>& f2 ) { typedef typename product<Type1, Type2>::type productType; TFOR_ALL_F_OP_F_OP_F(productType, res, =, Type1, f1, Op, Type2, f2) } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const UList<Type2>& f2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), f1, f2); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const tmp<Field<Type2> >& tf2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type2>::New(tf2); OpFunc(tRes(), f1, tf2()); reuseTmp<productType, Type2>::clear(tf2); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const UList<Type2>& f2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type1>::New(tf1); OpFunc(tRes(), tf1(), f2); reuseTmp<productType, Type1>::clear(tf1); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const tmp<Field<Type2> >& tf2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmpTmp<productType, Type1, Type1, Type2>::New(tf1, tf2); OpFunc(tRes(), tf1(), tf2()); reuseTmpTmp<productType, Type1, Type1, Type2>::clear(tf1, tf2); return tRes; } template<class Type, class Form, class Cmpt, int nCmpt> void OpFunc ( Field<typename product<Type, Form>::type>& res, const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs ) { typedef typename product<Type, Form>::type productType; TFOR_ALL_F_OP_F_OP_S (productType, res, =,Type, f1, Op, Form, static_cast<const Form&>(vs))} template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs) { typedef typename product<Type, Form>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), f1, static_cast<const Form&>(vs)); return tRes; } template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op ( const tmp<Field<Type> >& tf1, const VectorSpace<Form,Cmpt,nCmpt>& vs ) { typedef typename product<Type, Form>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type>::New(tf1); OpFunc(tRes(), tf1(), static_cast<const Form&>(vs)); reuseTmp<productType, Type>::clear(tf1); return tRes; } template<class Form, class Cmpt, int nCmpt, class Type> void OpFunc ( Field<typename product<Form, Type>::type>& res, const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1 ) { typedef typename product<Form, Type>::type productType; TFOR_ALL_F_OP_S_OP_F (productType, res, =,Form,static_cast<const Form&>(vs), Op, Type, f1) } template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1) { typedef typename product<Form, Type>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), static_cast<const Form&>(vs), f1); return tRes; } template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op ( const VectorSpace<Form,Cmpt,nCmpt>& vs, const tmp<Field<Type> >& tf1 ) { typedef typename product<Form, Type>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type>::New(tf1); OpFunc(tRes(), static_cast<const Form&>(vs), tf1()); reuseTmp<productType, Type>::clear(tf1); return tRes; }
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define PRODUCT_OPERATOR(product, op, opFunc) template<class Type1, class Type2> dimensioned<typename product<Type1, Type2>::type> operator op(const dimensioned<Type1>&, const dimensioned<Type2>&); template<class Type, class Form, class Cmpt, int nCmpt> dimensioned<typename product<Type, Form>::type> operator op ( const dimensioned<Type>&, const VectorSpace<Form,Cmpt,nCmpt>& ); template<class Type, class Form, class Cmpt, int nCmpt> dimensioned<typename product<Form, Type>::type> operator op ( const VectorSpace<Form,Cmpt,nCmpt>&, const dimensioned<Type>& );
#define PRODUCT_OPERATOR(product, Op, OpFunc) template<class Type1, class Type2> void OpFunc ( Field<typename product<Type1, Type2>::type>& res, const UList<Type1>& f1, const UList<Type2>& f2 ); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const UList<Type2>& f2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const tmp<Field<Type2> >& tf2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const UList<Type2>& f2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const tmp<Field<Type2> >& tf2); template<class Type, class Form, class Cmpt, int nCmpt> void OpFunc ( Field<typename product<Type, Form>::type>& res, const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs ); template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs); template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const tmp<Field<Type> >&tf1,const VectorSpace<Form,Cmpt,nCmpt>&vs); template<class Form, class Cmpt, int nCmpt, class Type> void OpFunc ( Field<typename product<Form, Type>::type>& res, const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1 ); template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1); template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>&vs,const tmp<Field<Type> >&tf1);
#define PRODUCT_OPERATOR(product, Op, OpFunc) template<class Type1, class Type2> void OpFunc ( Field<typename product<Type1, Type2>::type>& res, const UList<Type1>& f1, const UList<Type2>& f2 ) { typedef typename product<Type1, Type2>::type productType; TFOR_ALL_F_OP_F_OP_F(productType, res, =, Type1, f1, Op, Type2, f2) } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const UList<Type2>& f2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), f1, f2); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const tmp<Field<Type2> >& tf2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type2>::New(tf2); OpFunc(tRes(), f1, tf2()); reuseTmp<productType, Type2>::clear(tf2); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const UList<Type2>& f2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type1>::New(tf1); OpFunc(tRes(), tf1(), f2); reuseTmp<productType, Type1>::clear(tf1); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const tmp<Field<Type2> >& tf2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmpTmp<productType, Type1, Type1, Type2>::New(tf1, tf2); OpFunc(tRes(), tf1(), tf2()); reuseTmpTmp<productType, Type1, Type1, Type2>::clear(tf1, tf2); return tRes; } template<class Type, class Form, class Cmpt, int nCmpt> void OpFunc ( Field<typename product<Type, Form>::type>& res, const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs ) { typedef typename product<Type, Form>::type productType; TFOR_ALL_F_OP_F_OP_S (productType, res, =,Type, f1, Op, Form, static_cast<const Form&>(vs))} template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs) { typedef typename product<Type, Form>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), f1, static_cast<const Form&>(vs)); return tRes; } template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op ( const tmp<Field<Type> >& tf1, const VectorSpace<Form,Cmpt,nCmpt>& vs ) { typedef typename product<Type, Form>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type>::New(tf1); OpFunc(tRes(), tf1(), static_cast<const Form&>(vs)); reuseTmp<productType, Type>::clear(tf1); return tRes; } template<class Form, class Cmpt, int nCmpt, class Type> void OpFunc ( Field<typename product<Form, Type>::type>& res, const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1 ) { typedef typename product<Form, Type>::type productType; TFOR_ALL_F_OP_S_OP_F (productType, res, =,Form,static_cast<const Form&>(vs), Op, Type, f1) } template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1) { typedef typename product<Form, Type>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), static_cast<const Form&>(vs), f1); return tRes; } template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op ( const VectorSpace<Form,Cmpt,nCmpt>& vs, const tmp<Field<Type> >& tf1 ) { typedef typename product<Form, Type>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type>::New(tf1); OpFunc(tRes(), static_cast<const Form&>(vs), tf1()); reuseTmp<productType, Type>::clear(tf1); return tRes; }
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define PRODUCT_OPERATOR(product, op, opFunc) template<class Type1, class Type2> dimensioned<typename product<Type1, Type2>::type> operator op(const dimensioned<Type1>&, const dimensioned<Type2>&); template<class Type, class Form, class Cmpt, int nCmpt> dimensioned<typename product<Type, Form>::type> operator op ( const dimensioned<Type>&, const VectorSpace<Form,Cmpt,nCmpt>& ); template<class Type, class Form, class Cmpt, int nCmpt> dimensioned<typename product<Form, Type>::type> operator op ( const VectorSpace<Form,Cmpt,nCmpt>&, const dimensioned<Type>& );
#define PRODUCT_OPERATOR(product, Op, OpFunc) template<class Type1, class Type2> void OpFunc ( Field<typename product<Type1, Type2>::type>& res, const UList<Type1>& f1, const UList<Type2>& f2 ); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const UList<Type2>& f2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const tmp<Field<Type2> >& tf2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const UList<Type2>& f2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const tmp<Field<Type2> >& tf2); template<class Type, class Form, class Cmpt, int nCmpt> void OpFunc ( Field<typename product<Type, Form>::type>& res, const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs ); template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs); template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const tmp<Field<Type> >&tf1,const VectorSpace<Form,Cmpt,nCmpt>&vs); template<class Form, class Cmpt, int nCmpt, class Type> void OpFunc ( Field<typename product<Form, Type>::type>& res, const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1 ); template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1); template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>&vs,const tmp<Field<Type> >&tf1);
#define PRODUCT_OPERATOR(product, Op, OpFunc) template<class Type1, class Type2> void OpFunc ( Field<typename product<Type1, Type2>::type>& res, const UList<Type1>& f1, const UList<Type2>& f2 ) { typedef typename product<Type1, Type2>::type productType; TFOR_ALL_F_OP_F_OP_F(productType, res, =, Type1, f1, Op, Type2, f2) } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const UList<Type2>& f2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), f1, f2); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const tmp<Field<Type2> >& tf2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type2>::New(tf2); OpFunc(tRes(), f1, tf2()); reuseTmp<productType, Type2>::clear(tf2); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const UList<Type2>& f2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type1>::New(tf1); OpFunc(tRes(), tf1(), f2); reuseTmp<productType, Type1>::clear(tf1); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const tmp<Field<Type2> >& tf2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmpTmp<productType, Type1, Type1, Type2>::New(tf1, tf2); OpFunc(tRes(), tf1(), tf2()); reuseTmpTmp<productType, Type1, Type1, Type2>::clear(tf1, tf2); return tRes; } template<class Type, class Form, class Cmpt, int nCmpt> void OpFunc ( Field<typename product<Type, Form>::type>& res, const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs ) { typedef typename product<Type, Form>::type productType; TFOR_ALL_F_OP_F_OP_S (productType, res, =,Type, f1, Op, Form, static_cast<const Form&>(vs))} template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs) { typedef typename product<Type, Form>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), f1, static_cast<const Form&>(vs)); return tRes; } template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op ( const tmp<Field<Type> >& tf1, const VectorSpace<Form,Cmpt,nCmpt>& vs ) { typedef typename product<Type, Form>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type>::New(tf1); OpFunc(tRes(), tf1(), static_cast<const Form&>(vs)); reuseTmp<productType, Type>::clear(tf1); return tRes; } template<class Form, class Cmpt, int nCmpt, class Type> void OpFunc ( Field<typename product<Form, Type>::type>& res, const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1 ) { typedef typename product<Form, Type>::type productType; TFOR_ALL_F_OP_S_OP_F (productType, res, =,Form,static_cast<const Form&>(vs), Op, Type, f1) } template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1) { typedef typename product<Form, Type>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), static_cast<const Form&>(vs), f1); return tRes; } template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op ( const VectorSpace<Form,Cmpt,nCmpt>& vs, const tmp<Field<Type> >& tf1 ) { typedef typename product<Form, Type>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type>::New(tf1); OpFunc(tRes(), static_cast<const Form&>(vs), tf1()); reuseTmp<productType, Type>::clear(tf1); return tRes; }
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define PRODUCT_OPERATOR(product, op, opFunc) template<class Type1, class Type2> dimensioned<typename product<Type1, Type2>::type> operator op(const dimensioned<Type1>&, const dimensioned<Type2>&); template<class Type, class Form, class Cmpt, int nCmpt> dimensioned<typename product<Type, Form>::type> operator op ( const dimensioned<Type>&, const VectorSpace<Form,Cmpt,nCmpt>& ); template<class Type, class Form, class Cmpt, int nCmpt> dimensioned<typename product<Form, Type>::type> operator op ( const VectorSpace<Form,Cmpt,nCmpt>&, const dimensioned<Type>& );
#define PRODUCT_OPERATOR(product, Op, OpFunc) template<class Type1, class Type2> void OpFunc ( Field<typename product<Type1, Type2>::type>& res, const UList<Type1>& f1, const UList<Type2>& f2 ); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const UList<Type2>& f2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const tmp<Field<Type2> >& tf2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const UList<Type2>& f2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const tmp<Field<Type2> >& tf2); template<class Type, class Form, class Cmpt, int nCmpt> void OpFunc ( Field<typename product<Type, Form>::type>& res, const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs ); template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs); template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const tmp<Field<Type> >&tf1,const VectorSpace<Form,Cmpt,nCmpt>&vs); template<class Form, class Cmpt, int nCmpt, class Type> void OpFunc ( Field<typename product<Form, Type>::type>& res, const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1 ); template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1); template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>&vs,const tmp<Field<Type> >&tf1);
#define PRODUCT_OPERATOR(product, Op, OpFunc) template<class Type1, class Type2> void OpFunc ( Field<typename product<Type1, Type2>::type>& res, const UList<Type1>& f1, const UList<Type2>& f2 ) { typedef typename product<Type1, Type2>::type productType; TFOR_ALL_F_OP_F_OP_F(productType, res, =, Type1, f1, Op, Type2, f2) } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const UList<Type2>& f2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), f1, f2); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const tmp<Field<Type2> >& tf2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type2>::New(tf2); OpFunc(tRes(), f1, tf2()); reuseTmp<productType, Type2>::clear(tf2); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const UList<Type2>& f2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type1>::New(tf1); OpFunc(tRes(), tf1(), f2); reuseTmp<productType, Type1>::clear(tf1); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const tmp<Field<Type2> >& tf2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmpTmp<productType, Type1, Type1, Type2>::New(tf1, tf2); OpFunc(tRes(), tf1(), tf2()); reuseTmpTmp<productType, Type1, Type1, Type2>::clear(tf1, tf2); return tRes; } template<class Type, class Form, class Cmpt, int nCmpt> void OpFunc ( Field<typename product<Type, Form>::type>& res, const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs ) { typedef typename product<Type, Form>::type productType; TFOR_ALL_F_OP_F_OP_S (productType, res, =,Type, f1, Op, Form, static_cast<const Form&>(vs))} template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs) { typedef typename product<Type, Form>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), f1, static_cast<const Form&>(vs)); return tRes; } template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op ( const tmp<Field<Type> >& tf1, const VectorSpace<Form,Cmpt,nCmpt>& vs ) { typedef typename product<Type, Form>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type>::New(tf1); OpFunc(tRes(), tf1(), static_cast<const Form&>(vs)); reuseTmp<productType, Type>::clear(tf1); return tRes; } template<class Form, class Cmpt, int nCmpt, class Type> void OpFunc ( Field<typename product<Form, Type>::type>& res, const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1 ) { typedef typename product<Form, Type>::type productType; TFOR_ALL_F_OP_S_OP_F (productType, res, =,Form,static_cast<const Form&>(vs), Op, Type, f1) } template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1) { typedef typename product<Form, Type>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), static_cast<const Form&>(vs), f1); return tRes; } template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op ( const VectorSpace<Form,Cmpt,nCmpt>& vs, const tmp<Field<Type> >& tf1 ) { typedef typename product<Form, Type>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type>::New(tf1); OpFunc(tRes(), static_cast<const Form&>(vs), tf1()); reuseTmp<productType, Type>::clear(tf1); return tRes; }
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define PRODUCT_OPERATOR(product, op, opFunc) template<class Type1, class Type2> dimensioned<typename product<Type1, Type2>::type> operator op(const dimensioned<Type1>&, const dimensioned<Type2>&); template<class Type, class Form, class Cmpt, int nCmpt> dimensioned<typename product<Type, Form>::type> operator op ( const dimensioned<Type>&, const VectorSpace<Form,Cmpt,nCmpt>& ); template<class Type, class Form, class Cmpt, int nCmpt> dimensioned<typename product<Form, Type>::type> operator op ( const VectorSpace<Form,Cmpt,nCmpt>&, const dimensioned<Type>& );
#define PRODUCT_OPERATOR(product, Op, OpFunc) template<class Type1, class Type2> void OpFunc ( Field<typename product<Type1, Type2>::type>& res, const UList<Type1>& f1, const UList<Type2>& f2 ); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const UList<Type2>& f2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const tmp<Field<Type2> >& tf2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const UList<Type2>& f2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const tmp<Field<Type2> >& tf2); template<class Type, class Form, class Cmpt, int nCmpt> void OpFunc ( Field<typename product<Type, Form>::type>& res, const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs ); template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs); template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const tmp<Field<Type> >&tf1,const VectorSpace<Form,Cmpt,nCmpt>&vs); template<class Form, class Cmpt, int nCmpt, class Type> void OpFunc ( Field<typename product<Form, Type>::type>& res, const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1 ); template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1); template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>&vs,const tmp<Field<Type> >&tf1);
#define PRODUCT_OPERATOR(product, Op, OpFunc) template<class Type1, class Type2> void OpFunc ( Field<typename product<Type1, Type2>::type>& res, const UList<Type1>& f1, const UList<Type2>& f2 ) { typedef typename product<Type1, Type2>::type productType; TFOR_ALL_F_OP_F_OP_F(productType, res, =, Type1, f1, Op, Type2, f2) } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const UList<Type2>& f2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), f1, f2); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const tmp<Field<Type2> >& tf2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type2>::New(tf2); OpFunc(tRes(), f1, tf2()); reuseTmp<productType, Type2>::clear(tf2); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const UList<Type2>& f2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type1>::New(tf1); OpFunc(tRes(), tf1(), f2); reuseTmp<productType, Type1>::clear(tf1); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const tmp<Field<Type2> >& tf2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmpTmp<productType, Type1, Type1, Type2>::New(tf1, tf2); OpFunc(tRes(), tf1(), tf2()); reuseTmpTmp<productType, Type1, Type1, Type2>::clear(tf1, tf2); return tRes; } template<class Type, class Form, class Cmpt, int nCmpt> void OpFunc ( Field<typename product<Type, Form>::type>& res, const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs ) { typedef typename product<Type, Form>::type productType; TFOR_ALL_F_OP_F_OP_S (productType, res, =,Type, f1, Op, Form, static_cast<const Form&>(vs))} template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs) { typedef typename product<Type, Form>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), f1, static_cast<const Form&>(vs)); return tRes; } template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op ( const tmp<Field<Type> >& tf1, const VectorSpace<Form,Cmpt,nCmpt>& vs ) { typedef typename product<Type, Form>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type>::New(tf1); OpFunc(tRes(), tf1(), static_cast<const Form&>(vs)); reuseTmp<productType, Type>::clear(tf1); return tRes; } template<class Form, class Cmpt, int nCmpt, class Type> void OpFunc ( Field<typename product<Form, Type>::type>& res, const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1 ) { typedef typename product<Form, Type>::type productType; TFOR_ALL_F_OP_S_OP_F (productType, res, =,Form,static_cast<const Form&>(vs), Op, Type, f1) } template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1) { typedef typename product<Form, Type>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), static_cast<const Form&>(vs), f1); return tRes; } template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op ( const VectorSpace<Form,Cmpt,nCmpt>& vs, const tmp<Field<Type> >& tf1 ) { typedef typename product<Form, Type>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type>::New(tf1); OpFunc(tRes(), static_cast<const Form&>(vs), tf1()); reuseTmp<productType, Type>::clear(tf1); return tRes; }
// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define PRODUCT_OPERATOR(product, op, opFunc) template<class Type1, class Type2> dimensioned<typename product<Type1, Type2>::type> operator op(const dimensioned<Type1>&, const dimensioned<Type2>&); template<class Type, class Form, class Cmpt, int nCmpt> dimensioned<typename product<Type, Form>::type> operator op ( const dimensioned<Type>&, const VectorSpace<Form,Cmpt,nCmpt>& ); template<class Type, class Form, class Cmpt, int nCmpt> dimensioned<typename product<Form, Type>::type> operator op ( const VectorSpace<Form,Cmpt,nCmpt>&, const dimensioned<Type>& );
#define PRODUCT_OPERATOR(product, Op, OpFunc) template<class Type1, class Type2> void OpFunc ( Field<typename product<Type1, Type2>::type>& res, const UList<Type1>& f1, const UList<Type2>& f2 ); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const UList<Type2>& f2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const tmp<Field<Type2> >& tf2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const UList<Type2>& f2); template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const tmp<Field<Type2> >& tf2); template<class Type, class Form, class Cmpt, int nCmpt> void OpFunc ( Field<typename product<Type, Form>::type>& res, const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs ); template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs); template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const tmp<Field<Type> >&tf1,const VectorSpace<Form,Cmpt,nCmpt>&vs); template<class Form, class Cmpt, int nCmpt, class Type> void OpFunc ( Field<typename product<Form, Type>::type>& res, const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1 ); template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1); template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>&vs,const tmp<Field<Type> >&tf1);
#define PRODUCT_OPERATOR(product, Op, OpFunc) template<class Type1, class Type2> void OpFunc ( Field<typename product<Type1, Type2>::type>& res, const UList<Type1>& f1, const UList<Type2>& f2 ) { typedef typename product<Type1, Type2>::type productType; TFOR_ALL_F_OP_F_OP_F(productType, res, =, Type1, f1, Op, Type2, f2) } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const UList<Type2>& f2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), f1, f2); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const UList<Type1>& f1, const tmp<Field<Type2> >& tf2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type2>::New(tf2); OpFunc(tRes(), f1, tf2()); reuseTmp<productType, Type2>::clear(tf2); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const UList<Type2>& f2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type1>::New(tf1); OpFunc(tRes(), tf1(), f2); reuseTmp<productType, Type1>::clear(tf1); return tRes; } template<class Type1, class Type2> tmp<Field<typename product<Type1, Type2>::type> > operator Op(const tmp<Field<Type1> >& tf1, const tmp<Field<Type2> >& tf2) { typedef typename product<Type1, Type2>::type productType; tmp<Field<productType> > tRes = reuseTmpTmp<productType, Type1, Type1, Type2>::New(tf1, tf2); OpFunc(tRes(), tf1(), tf2()); reuseTmpTmp<productType, Type1, Type1, Type2>::clear(tf1, tf2); return tRes; } template<class Type, class Form, class Cmpt, int nCmpt> void OpFunc ( Field<typename product<Type, Form>::type>& res, const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs ) { typedef typename product<Type, Form>::type productType; TFOR_ALL_F_OP_F_OP_S (productType, res, =,Type, f1, Op, Form, static_cast<const Form&>(vs))} template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op(const UList<Type>& f1, const VectorSpace<Form,Cmpt,nCmpt>& vs) { typedef typename product<Type, Form>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), f1, static_cast<const Form&>(vs)); return tRes; } template<class Type, class Form, class Cmpt, int nCmpt> tmp<Field<typename product<Type, Form>::type> > operator Op ( const tmp<Field<Type> >& tf1, const VectorSpace<Form,Cmpt,nCmpt>& vs ) { typedef typename product<Type, Form>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type>::New(tf1); OpFunc(tRes(), tf1(), static_cast<const Form&>(vs)); reuseTmp<productType, Type>::clear(tf1); return tRes; } template<class Form, class Cmpt, int nCmpt, class Type> void OpFunc ( Field<typename product<Form, Type>::type>& res, const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1 ) { typedef typename product<Form, Type>::type productType; TFOR_ALL_F_OP_S_OP_F (productType, res, =,Form,static_cast<const Form&>(vs), Op, Type, f1) } template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op(const VectorSpace<Form,Cmpt,nCmpt>& vs, const UList<Type>& f1) { typedef typename product<Form, Type>::type productType; tmp<Field<productType> > tRes(new Field<productType>(f1.size())); OpFunc(tRes(), static_cast<const Form&>(vs), f1); return tRes; } template<class Form, class Cmpt, int nCmpt, class Type> tmp<Field<typename product<Form, Type>::type> > operator Op ( const VectorSpace<Form,Cmpt,nCmpt>& vs, const tmp<Field<Type> >& tf1 ) { typedef typename product<Form, Type>::type productType; tmp<Field<productType> > tRes = reuseTmp<productType, Type>::New(tf1); OpFunc(tRes(), static_cast<const Form&>(vs), tf1()); reuseTmp<productType, Type>::clear(tf1); return tRes; }
